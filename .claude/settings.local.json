{
  "permissions": {
    "allow": [
      "Bash(go test:*)",
      "Bash(go build:*)",
      "Bash(npm run build)",
      "Bash(./gmssh --help:*)",
      "Bash(./gmssh:*)",
      "Bash(echo:*)",
      "Bash(curl:*)",
      "Bash(kill:*)",
      "mcp__playwright__browser_navigate",
      "mcp__playwright__browser_click",
      "mcp__playwright__browser_take_screenshot",
      "mcp__playwright__browser_close",
      "mcp__playwright__browser_resize",
      "Bash(go get:*)",
      "Bash(go mod tidy:*)",
      "Bash(npx tsc:*)",
      "Bash(git add:*)",
      "Bash(git init:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nfeat\\(portal\\): add portal types and configuration\n\n- Add Protocol type with TCP, HTTP, WebSocket constants\n- Add PortMapping struct for port mapping configuration\n- Add PortalConfig, ClientConfig, ServerConfig structs\n- Add TokenConfig for authentication\n- Add ConnectionConfig with defaults\n- Add MappingStatus for runtime state tracking\n- Add DefaultConnectionConfig\\(\\) helper function\n- Add unit tests for types\nEOF\n\\)\")",
      "Bash(/tmp/test_smux_tls.go << 'EOF'\npackage main\n\nimport \\(\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/xtaci/smux\"\n\\)\n\nfunc generateTestCert\\(\\) \\(tls.Certificate, *x509.CertPool, error\\) {\n\tpriv, err := ecdsa.GenerateKey\\(elliptic.P256\\(\\), rand.Reader\\)\n\tif err != nil {\n\t\treturn tls.Certificate{}, nil, fmt.Errorf\\(\"failed to generate key: %w\", err\\)\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: big.NewInt\\(1\\),\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Test\"},\n\t\t},\n\t\tNotBefore:             time.Now\\(\\),\n\t\tNotAfter:              time.Now\\(\\).Add\\(time.Hour\\),\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},\n\t\tBasicConstraintsValid: true,\n\t\tIPAddresses:           []net.IP{net.ParseIP\\(\"127.0.0.1\"\\)},\n\t}\n\n\tcertDER, err := x509.CreateCertificate\\(rand.Reader, &template, &template, &priv.PublicKey, priv\\)\n\tif err != nil {\n\t\treturn tls.Certificate{}, nil, fmt.Errorf\\(\"failed to create certificate: %w\", err\\)\n\t}\n\n\tcertPEM := pem.EncodeToMemory\\(&pem.Block{Type: \"CERTIFICATE\", Bytes: certDER}\\)\n\tprivBytes, err := x509.MarshalECPrivateKey\\(priv\\)\n\tif err != nil {\n\t\treturn tls.Certificate{}, nil, fmt.Errorf\\(\"failed to marshal private key: %w\", err\\)\n\t}\n\tkeyPEM := pem.EncodeToMemory\\(&pem.Block{Type: \"EC PRIVATE KEY\", Bytes: privBytes}\\)\n\n\tcert, err := tls.X509KeyPair\\(certPEM, keyPEM\\)\n\tif err != nil {\n\t\treturn tls.Certificate{}, nil, fmt.Errorf\\(\"failed to load key pair: %w\", err\\)\n\t}\n\n\tpool := x509.NewCertPool\\(\\)\n\tpool.AppendCertsFromPEM\\(certPEM\\)\n\n\treturn cert, pool, nil\n}\n\nfunc main\\(\\) {\n\tcert, pool, err := generateTestCert\\(\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"Failed to generate test certificates: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\n\tserverConfig := &tls.Config{\n\t\tCertificates:       []tls.Certificate{cert},\n\t\tInsecureSkipVerify: true,\n\t}\n\n\tclientConfig := &tls.Config{\n\t\tRootCAs:            pool,\n\t\tInsecureSkipVerify: true,\n\t}\n\n\t// Create listener\n\tlistener, err := net.Listen\\(\"tcp\", \"127.0.0.1:0\"\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"Failed to create listener: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\tdefer listener.Close\\(\\)\n\n\taddr := listener.Addr\\(\\).\\(*net.TCPAddr\\)\n\tfmt.Printf\\(\"Listening on port %d\\\\n\", addr.Port\\)\n\n\t// Server goroutine\n\tserverDone := make\\(chan error, 1\\)\n\tgo func\\(\\) {\n\t\tconn, err := listener.Accept\\(\\)\n\t\tif err != nil {\n\t\t\tserverDone <- fmt.Errorf\\(\"accept failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\n\t\t// TLS handshake\n\t\ttlsConn := tls.Server\\(conn, serverConfig\\)\n\t\tif err := tlsConn.Handshake\\(\\); err != nil {\n\t\t\tconn.Close\\(\\)\n\t\t\tserverDone <- fmt.Errorf\\(\"TLS handshake failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\n\t\tsession, err := smux.Server\\(tlsConn, nil\\)\n\t\tif err != nil {\n\t\t\ttlsConn.Close\\(\\)\n\t\t\tserverDone <- fmt.Errorf\\(\"smux.Server failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\t\tdefer session.Close\\(\\)\n\n\t\tstream, err := session.AcceptStream\\(\\)\n\t\tif err != nil {\n\t\t\tserverDone <- fmt.Errorf\\(\"AcceptStream failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close\\(\\)\n\n\t\tbuf := make\\([]byte, 1024\\)\n\t\tn, err := stream.Read\\(buf\\)\n\t\tif err != nil {\n\t\t\tserverDone <- fmt.Errorf\\(\"stream read failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\n\t\t_, err = stream.Write\\(buf[:n]\\)\n\t\tif err != nil {\n\t\t\tserverDone <- fmt.Errorf\\(\"stream write failed: %w\", err\\)\n\t\t\treturn\n\t\t}\n\t\tserverDone <- nil\n\t}\\(\\)\n\n\ttime.Sleep\\(100 * time.Millisecond\\)\n\n\t// Connect client\n\tconn, err := net.Dial\\(\"tcp\", fmt.Sprintf\\(\"127.0.0.1:%d\", addr.Port\\)\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"Failed to dial: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\n\t// TLS handshake\n\ttlsConn := tls.Client\\(conn, clientConfig\\)\n\tif err := tlsConn.Handshake\\(\\); err != nil {\n\t\tconn.Close\\(\\)\n\t\tfmt.Printf\\(\"TLS handshake failed: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\n\tsession, err := smux.Client\\(tlsConn, nil\\)\n\tif err != nil {\n\t\ttlsConn.Close\\(\\)\n\t\tfmt.Printf\\(\"smux.Client failed: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\tdefer session.Close\\(\\)\n\n\tstream, err := session.OpenStream\\(\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"OpenStream failed: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\tdefer stream.Close\\(\\)\n\n\ttestData := []byte\\(\"hello, smux!\"\\)\n\t_, err = stream.Write\\(testData\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"stream write failed: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\n\tbuf := make\\([]byte, 1024\\)\n\tn, err := stream.Read\\(buf\\)\n\tif err != nil {\n\t\tfmt.Printf\\(\"stream read failed: %v\\\\n\", err\\)\n\t\treturn\n\t}\n\n\tif string\\(buf[:n]\\) != string\\(testData\\) {\n\t\tfmt.Printf\\(\"Received %q, want %q\\\\n\", buf[:n], testData\\)\n\t\treturn\n\t}\n\n\tfmt.Printf\\(\"Success! Received: %s\\\\n\", buf[:n]\\)\n\n\t// Wait for server\n\tselect {\n\tcase err := <-serverDone:\n\t\tif err != nil {\n\t\t\tfmt.Printf\\(\"Server error: %v\\\\n\", err\\)\n\t\t}\n\tcase <-time.After\\(5 * time.Second\\):\n\t\tfmt.Println\\(\"Server timeout\"\\)\n\t}\n}\nEOF)",
      "Bash(go run:*)",
      "Bash(go doc:*)",
      "Bash(git reset:*)",
      "Bash(gofmt -d:*)",
      "Bash(npm test:*)",
      "Bash(pkill:*)",
      "Bash(lsof:*)",
      "mcp__playwright__browser_snapshot",
      "mcp__playwright__browser_wait_for",
      "mcp__playwright__browser_press_key"
    ]
  }
}
